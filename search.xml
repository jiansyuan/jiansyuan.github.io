<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Solution of USACO12OPEN G(P3067)</title>
      <link href="/2023/03/19/solution-of-USACO12OPEN-G/"/>
      <url>/2023/03/19/solution-of-USACO12OPEN-G/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E9%A2%98%E6%84%8F">题意</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>有可重集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>, 求它的非空子集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>的个数, 满足: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>A</mi><mo>∪</mo><mi>B</mi><mo separator="true">,</mo><mi>A</mi><mo>∪</mo><mi>B</mi><mo>=</mo><mi mathvariant="normal">∅</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><msub><mi>A</mi><mi>i</mi></msub><mo>=</mo><mi mathvariant="normal">Σ</mi><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X=A\cup B, A\cup B=\emptyset, \Sigma A_i=\Sigma B_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>.<br>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">|S| \leq 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">S_i \leq 10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>.</p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>考虑使用<a href="https://oi-wiki.org/search/bidirectional/">Meet in The Middle思路</a>, 时间复杂度是朴素算法的平方根.<br>一般地, 把集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>分为两部分来搜索, 于是对于每个元素就有了三种分支: 不选, 选入左部分 和 选入右部分.<br>最后进行两部分的合并操作, 关键在于去重.</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">bitset&lt;1&lt;&lt;10&gt; vis[<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, bitset&lt;1&lt;&lt;10&gt; &gt; mp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> dep, sum, sta;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, mid;</span><br><span class="line">    cin&gt;&gt;n, mid = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">stable_sort</span>(a, a+n);</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(Node&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x =q.<span class="built_in">front</span>().dep, y=q.<span class="built_in">front</span>().sum, z=q.<span class="built_in">front</span>().sta;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x==mid) &#123;</span><br><span class="line">            mp[y].<span class="built_in">set</span>(z);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(Node&#123;x+<span class="number">1</span>, y, z&#125;);</span><br><span class="line">        q.<span class="built_in">push</span>(Node&#123;x+<span class="number">1</span>, y+a[x], z|(<span class="number">1</span>&lt;&lt;x)&#125;);</span><br><span class="line">        q.<span class="built_in">push</span>(Node&#123;x+<span class="number">1</span>, y-a[x], z|(<span class="number">1</span>&lt;&lt;x)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(Node&#123;mid, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x =q.<span class="built_in">front</span>().dep, y=q.<span class="built_in">front</span>().sum, z=q.<span class="built_in">front</span>().sta;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x==n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(y)) &#123;</span><br><span class="line">                bitset&lt;1&lt;&lt;10&gt; <span class="built_in">tmp</span>(mp[y]);</span><br><span class="line">               tmp &amp;=~vis[z], ans+=tmp.<span class="built_in">count</span>(), vis[z]|=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(Node&#123;x+<span class="number">1</span>, y, z&#125;);</span><br><span class="line">        q.<span class="built_in">push</span>(Node&#123;x+<span class="number">1</span>, y+a[x], z|(<span class="number">1</span>&lt;&lt;(x-mid))&#125;);</span><br><span class="line">        q.<span class="built_in">push</span>(Node&#123;x+<span class="number">1</span>, y-a[x], z|(<span class="number">1</span>&lt;&lt;(x-mid))&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> solution </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Theorem Proving &amp; Program Verification by Coq</title>
      <link href="/2023/03/06/Theorem-Proving-and-Program-Verification-By-Coq/"/>
      <url>/2023/03/06/Theorem-Proving-and-Program-Verification-By-Coq/</url>
      
        <content type="html"><![CDATA[<h2 id="content"><a class="markdownIt-Anchor" href="#content"></a> Content</h2><ul><li><a href="#content">Content</a></li><li><a href="#introduction">Introduction</a></li><li><a href="#1-proof-equation">1. Proof Equation</a><ul><li><a href="#11-proving-right-inverse-property">1.1 Proving Right Inverse Property</a></li><li><a href="#12-proving-right-unit-property">1.2 Proving Right Unit Property</a></li><li><a href="#13-proving-double-negation-property">1.3 Proving Double Negation Property</a></li></ul></li><li><a href="#2-inductive-type-recursive-definitions-and-inductive-proof">2. Inductive Type, Recursive Definitions and Inductive proof</a></li><li><a href="#%E8%BF%99%E5%87%A0%E5%A4%A9%E4%B8%8D%E5%86%99%E4%BA%86%E5%BE%85%E7%BB%AD"><strong>这几天不写了，待续。。。。</strong></a></li></ul><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><blockquote><p>If we say that programming is through writing code, the combination of simple functions &amp; components to realize the complex assembly, then proof is the combination of some simple proof steps to make the complex proof.<br>Theorem proving tools like Coq &amp; Isabelle allow us to describe mathematical definitions &amp; mathematical proofs in the form of codes.</p></blockquote><p>We use Coq here: <a href="https://github.com/coq/platform/releases/">Coq-Release@github.com</a>. The <a href="https://jscoq.github.io/wa/">online version of Coq</a> is also able to be used.<br>Here is a link to <a href="https://coq.inria.fr/refman/coq-tacindex.html">the official Coq documentation</a> for review &amp; reference, in order for readers’ better reading.<br>This article only guarantees that readers can establish a preliminary understanding of formal theorem proving &amp; program verification. If you’re looking for a book with a richer and more substantial introduction to get familiar with Coq, I recommend you read the <em>“Software Foundations Vol.1: Logical Foundations”</em> at least.</p><h2 id="1-proof-equation"><a class="markdownIt-Anchor" href="#1-proof-equation"></a> 1. Proof Equation</h2><p>Equation is one of the base of math, we started with a proof about group theory.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span> Group.</span><br><span class="line"><span class="keyword">Class</span> GroupOperator: <span class="keyword">Type</span> := &#123;</span><br><span class="line">    tote_set: <span class="keyword">Type</span>;</span><br><span class="line">    zero: tote_set;</span><br><span class="line">    add: tote_set -&gt; tote_set -&gt; tote_set;</span><br><span class="line">    neg: tote_set -&gt; tote_set;</span><br><span class="line">&#125;.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;0&quot;</span> := (zero).</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;a + b&quot;</span> := (add a b).</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;- a&quot;</span> := (neg a).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> <span class="keyword">forall</span> (G: GroupOperator) (x y: tote_set), x + y = y + x.</span><br></pre></td></tr></table></figure><p>First, we have to define which operations a group contains.<br>We can write without these coq-reserve words such as <em>Type or Class</em> here. To define a group operation, you can define the set <em>tote_set</em> first, &amp; then it should contain the unit element <em>zero</em>, the binary operation <em>add</em> &amp; an inverse operation <em>neg</em>.</p><p>The key word <em>Notation</em> in coq helps describe the related properties by using refiner words.</p><p>At the lastest line, the order <em>Check</em> can be understood as asking computer to check if the expression is syntactically legal. The point is that it just does in syntax but not about the proof.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> GroupProperties (G: GroupOperator): <span class="keyword">Prop</span> := &#123;</span><br><span class="line">    associate: <span class="keyword">forall</span> (a b c: tote_set), (a + b) + c = a + (b + c);</span><br><span class="line">    left_unit_clear: <span class="keyword">forall</span> (a: tote_set), <span class="number">0</span> + a = a;</span><br><span class="line">    left_inverstion_clear: <span class="keyword">forall</span> (a: tote_set), (- a) + a = <span class="number">0</span>;</span><br><span class="line">&#125;.</span><br></pre></td></tr></table></figure><p>We list 3 laws of the group, clearing left unit, clearing inverstion &amp; associative law. It 's useful to the next part.</p><h3 id="11-proving-right-inverse-property"><a class="markdownIt-Anchor" href="#11-proving-right-inverse-property"></a> 1.1 Proving Right Inverse Property</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> right_inverstion_clear &#123;G: GroupOperator&#125; &#123;GP: GroupProperties G&#125;: </span><br><span class="line">(<span class="keyword">forall</span> (a: tote_set), a + (- a) = <span class="number">0</span>).</span><br></pre></td></tr></table></figure><p>The things after <em>Theorem</em> here needed to proof by us, Try to do!</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Require</span> <span class="keyword">Import</span> <span class="keyword">Setoid</span>.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> a.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (left_unit_clear (a + (- a))).</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (left_inverstion_clear (- a)) <span class="built_in">at</span> <span class="number">1.</span></span><br><span class="line">  <span class="built_in">rewrite</span> associate.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (associate (- a)).</span><br><span class="line">  <span class="built_in">rewrite</span> left_inverstion_clear.</span><br><span class="line">  <span class="built_in">rewrite</span> left_unit_clear.</span><br><span class="line">  <span class="built_in">rewrite</span> left_inverstion_clear.</span><br><span class="line">  <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure><p>Here is the classical proof in group theory, that’s derived from the two properties of left unit element &amp; left inverse element, to right inverse element.</p><p>We use <em>intros</em> to get the theorem <em>a + (- a) = 0</em> that awaits to be prooved at line 1.<br>Then use the keyword <em>rewrite</em> to convert the existing properties of this equation, the arrow to the left is “&lt;-” means to use properties to transform a certain item of the equation from left to right, the “-&gt;” is opposite operation, followed by the parentheses after the property name Content is used to match corresponding items. If you want to operate only on the matching item at a certain position, you can use the keyword <em>at</em>; if you think that Coq will not cause ambiguity with a certain instruction, you can even ignore the content of the parentheses.<br>Finally, the <em>reflexivity</em> says that the equation is reflexive, &amp; now the equation is exactly the same on both sides, so it’s all of the proof. The <em>Qed.</em> is the end of the <em>Proof.</em> above.We have done all the work of this stupid theorem.</p><p>If you have doubts about a part of this part of the code, please leave it to CoqIDE to run this proof, it will be intuitive to observe the equation change in the goal window on the right. Use the shortcut keys “Ctrl + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↑</mo></mrow><annotation encoding="application/x-tex">\uparrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>” and “Ctrl + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↓</mo></mrow><annotation encoding="application/x-tex">\downarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>” to quickly switch the row up or down.</p><h3 id="12-proving-right-unit-property"><a class="markdownIt-Anchor" href="#12-proving-right-unit-property"></a> 1.2 Proving Right Unit Property</h3><p>Based on the fundamental properties &amp; the results we have proved, it is easy to prove the right unit property corresponding to the left unit property. The right unit property can be expressed as the <em>a + 0 = a</em>.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> right_unit_clear &#123;G: GroupOperator&#125; &#123;GP: GroupProperties G&#125;:</span><br><span class="line">  <span class="keyword">forall</span> (a: tote_set), a + <span class="number">0</span> = a.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span>.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (left_inverstion_clear (a)).</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- associate, right_inverstion_clear, left_unit_clear.</span><br><span class="line">  <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure><p>So it was proven that right unit property. It is possible to write multiple commands together in Coq as in the above code.</p><h3 id="13-proving-double-negation-property"><a class="markdownIt-Anchor" href="#13-proving-double-negation-property"></a> 1.3 Proving Double Negation Property</h3><p>Next prove the double negation signelimination property.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> double_negation &#123;G: GroupOperator&#125; &#123;GP: GroupProperties G&#125;:</span><br><span class="line">  <span class="keyword">forall</span> (a: tote_set), - - a = a.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span>.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (left_unit_clear (--a)).</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (right_inverstion_clear (a)).</span><br><span class="line">  <span class="built_in">rewrite</span> associate, right_inverstion_clear, right_unit_clear.</span><br><span class="line">  <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure><h2 id="2-inductive-type-recursive-definitions-and-inductive-proof"><a class="markdownIt-Anchor" href="#2-inductive-type-recursive-definitions-and-inductive-proof"></a> 2. Inductive Type, Recursive Definitions and Inductive proof</h2><h2 id="这几天不写了待续"><a class="markdownIt-Anchor" href="#这几天不写了待续"></a> <strong>这几天不写了，待续。。。。</strong></h2><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><munderover><mo>∑</mo><munderover><mo>∑</mo><mn>114514</mn><mn>1919810</mn></munderover><munderover><mo>∑</mo><mn>114514</mn><mn>1919810</mn></munderover></munderover><munderover><mo>∑</mo><munderover><mo>∑</mo><mn>114514</mn><mn>1919810</mn></munderover><munderover><mo>∑</mo><mn>114514</mn><mn>1919810</mn></munderover></munderover></munderover></mrow><annotation encoding="application/x-tex">\sum_{\sum_{\sum_{114514}^{1919810}}^{\sum_{114514}^{1919810}}}^{\sum_{\sum_{114514}^{1919810}}^{\sum_{114514}^{1919810}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> coq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome, guest.</title>
      <link href="/2023/03/05/hi-guest/"/>
      <url>/2023/03/05/hi-guest/</url>
      
        <content type="html"><![CDATA[<h2 id="hi"><a class="markdownIt-Anchor" href="#hi"></a> Hi!</h2><p>Welcome to my blog website<br><a href="../../../../about">About this website.</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
