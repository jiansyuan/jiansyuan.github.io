<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Talk about Tree Chain Partition</title>
      <link href="/2023/03/26/Talk-About-Tree-Chain-Partition/"/>
      <url>/2023/03/26/Talk-About-Tree-Chain-Partition/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h2 id="先决知识"><a class="markdownIt-Anchor" href="#先决知识"></a> 先决知识</h2><ol><li>基本的图论和数据结构知识</li><li>线段树(Segment Tree)</li><li>DFS序(Depth-first-search SEQ.)</li></ol><h2 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h2><p>树链剖分(Tree Chain Partition)的思路是将一整颗树剖分若干条链, 组合这些链成为线性结构从而能使用其他数据结构维护信息.具体地, 按照判链条件来讲有多种剖分方式, 如重链剖分, 长链剖分以及实链剖分. 本文要介绍被广泛运用的重链剖分.</p><p>重链剖分以子树的大小为依据来确定该子树的根节点是否在链上, 链的数量不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> 条. 链在树的结构上是延续的, 一条链中的每一个节点所映射到的线性结构上的标号也是延续的.  这样能实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omicron(\log_2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> 级别的任意两点之间的查询树上路径和, 树上路径极值等, 以及对树上单点或区间值的修改操作.</p><h2 id="给出定义"><a class="markdownIt-Anchor" href="#给出定义"></a> 给出定义</h2><ol><li>重子节点(重儿子): 对于一个节点的所有子节点中, 所有子树的节点最多的那一个子节点.</li><li>轻子节点(轻儿子): 对于一个节点的所有子节点中, 所有不是重子节点的其他子节点.</li><li>重边: 一条边中如果深度更深的节点是重子节点, 那这条边就叫重边.</li><li>轻边: 所有不是重边的边.</li><li>重链: 由一或多条重边连接成的延续的路径.</li><li>轻链: 所有不是重链的链.</li></ol><p><img src="/image/Talk-About-Tree-Chain-Partition1.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Graph-Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solution of HNOI2008 “玩具装箱”(P3195)</title>
      <link href="/2023/03/22/Solution-of-HNOI2008-Pack-Toys/"/>
      <url>/2023/03/22/Solution-of-HNOI2008-Pack-Toys/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E9%A2%98%E6%84%8F">题意</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p><s>今天不想简化题面。。。</s></p><p>P 教授要去看奥运，但是他舍不得他的玩具，于是他决定把所有的玩具运到北京。</p><p>他使用自己的压缩器进行压缩。这个压缩器可以将任意物品变成一维，再放到一种特殊的一维容器中。P 教授有编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>…</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\dots n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> 件玩具，玩具经过压缩后会变成一维，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> 件件玩具压缩后长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>。</p><p>为了方便整理，P 教授要求：</p><ul><li>在一个一维容器中，玩具的编号是连续的；</li><li>如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果要将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> 号玩具到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> 号玩具放到同一个容器中，则容器长度不小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo>+</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mi>i</mi></mrow><mi>j</mi></msubsup><msub><mi>C</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">x=j-i+\sum_{k=i}^{j}C_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>。</li></ul><p>制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>，其制作费用为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>L</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(x-L)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> 是一个常量。</p><p>P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>。试求最小费用。</p><p>数据范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1\le n\le 5\times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>L</mi><mo separator="true">,</mo><msub><mi>C</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">1\le L,C_i\le 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p><strong>DP : 斜率优化+单调队列</strong></p><h3 id="朴素的解法"><a class="markdownIt-Anchor" href="#朴素的解法"></a> 朴素的解法</h3><p>令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">ans[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>为选到第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>个玩具时的最小费用, 列出朴素的状态转移方程:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><munder><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mrow><mo stretchy="false">(</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>L</mi><mo>+</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow><mi>i</mi></msubsup><msub><mi>C</mi><mi>k</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">ans[i]=\min_{0\le j&lt;i}{(ans[j]+(i-j-1-L+\Sigma_{k=j+1}^iC_k)^2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><p>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>i</mi></msubsup><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">sum[i]=\sum_{j=0}^iC_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> :</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><munder><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mrow><mo stretchy="false">(</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>L</mi><mo>+</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">ans[i]=\min_{0\le j&lt;i}{(ans[j]+(i-j-1-L+sum[i]-sum[j])^2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><p>然后复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omicron(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>, 呜呜呜到底要怎么办呢.</p><p>先把式子化简, 令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">f[i]=sum[i]+i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>L</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">L&#x27;=L+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>, 就有了:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><munder><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mrow><mo stretchy="false">(</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">ans[i]=\min_{0\le j&lt;i}{(ans[j]+(f[i]-f[j]-L^{\prime})^2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><h3 id="斜率方程"><a class="markdownIt-Anchor" href="#斜率方程"></a> 斜率方程</h3><p>把和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>无关的项移到左侧:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><munder><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mrow><mo stretchy="false">{</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><msup><mo stretchy="false">]</mo><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>−</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">ans[i]-(f[i]-L&#x27;)^2=\min_{0\le j&lt;i}{\{ans[j]+f[j]^2+2f[j](L&#x27;-f[i])\}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><p>把一次函数的斜截式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>k</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y=kx+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>移动得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>−</mo><mi>k</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y-kx=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>.<br>发现可以这样表示:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>x</mi><mi>j</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>y</mi><mi>j</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><msup><mo stretchy="false">]</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>k</mi><mi>i</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><mn>2</mn><mo stretchy="false">(</mo><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>−</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>b</mi><mi>i</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><msup><mi>L</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} x_j&amp;=f[j]\\ y_j&amp;=ans[j]+f[j]^2\\ k_i&amp;=-2(L&#x27;-f[i])\\ b_i&amp;=ans[i]-(f[i]-L&#x27;)^2\\ \end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><p>所以转移方程也就是:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><munder><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mrow><mo stretchy="false">(</mo><msub><mi>y</mi><mi>j</mi></msub><mo>−</mo><msub><mi>k</mi><mi>i</mi></msub><msub><mi>x</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">b_i=\min_{0\le j&lt;i}{(y_j-k_ix_j)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><p>其实就是求直线最小的截率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>.<br>显然地, 答案在点集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{(x_i, y_i)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>的下凸壳上, 具有决策单调性, 请自行证明.</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line">ll n, L, f[N], ans[N], qu[N], hd, tl;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pow2(a) pow(a, 2)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">slope</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)((ans[y]+<span class="built_in">pow2</span>(f[y]+L))-(ans[x]+<span class="built_in">pow2</span>(f[x]+L)))/(<span class="number">2.0</span>*(f[y]-f[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;L, L++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, tmp;i&lt;=n;i++) cin&gt;&gt;tmp, f[i]=f[i<span class="number">-1</span>]+tmp+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">       <span class="keyword">while</span>(hd&lt;tl&amp;&amp;<span class="built_in">slope</span>(qu[hd], qu[hd+<span class="number">1</span>])&lt;=f[i]) hd++;</span><br><span class="line">       ans[i]=ans[qu[hd]]+<span class="built_in">pow2</span>(f[i]-f[qu[hd]]-L);</span><br><span class="line">       <span class="keyword">while</span>(hd&lt;tl&amp;&amp;<span class="built_in">slope</span>(qu[tl], i)&lt;<span class="built_in">slope</span>(qu[tl<span class="number">-1</span>], qu[tl])) tl--;</span><br><span class="line">       qu[++tl]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans[n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> solution </tag>
            
            <tag> HNOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solution of Codeforces372 C</title>
      <link href="/2023/03/21/Solution-of-CF372C/"/>
      <url>/2023/03/21/Solution-of-CF372C/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E9%A2%98%E6%84%8F">题意</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>个相邻 距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>的地点编号为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1-n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>. 有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>个事件分别在地点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> 时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>发生, 在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>时位于地点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><msub><mi>t</mi><mi>i</mi></msub></msub></mrow><annotation encoding="application/x-tex">x_{t_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>能获得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>−</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><msub><mi>t</mi><mi>i</mi></msub></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">b_i-|a_i-x_{t_i}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>的收益, 要求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">∣</mi><mo>≤</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">|x_i-x_{i+1}|\le d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>. 求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mo>∑</mo><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>−</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><msub><mi>t</mi><mi>i</mi></msub></msub><mi mathvariant="normal">∣</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\max{(\sum{b_i-|a_i-x_{t_i}|})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>.</p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>150000</mn><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>300</mn><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>d</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\le n\le 150000, 1\le m\le 300, 1\le d\le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>;<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mn>1000000000</mn><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><msub><mi>t</mi><mi>i</mi></msub><mo>≤</mo><mn>1000000000</mn></mrow><annotation encoding="application/x-tex">1\le a_i\le n, 1\le b_i\le 1000000000, 1\le t_i\le 1000000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>.</p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>考虑DP. 先令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[x][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><msub><mi>t</mi><mi>x</mi></msub></msub><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x_{t_x}=y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>情况下的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>x</mi></msubsup><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>−</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><msub><mi>t</mi><mi>i</mi></msub></msub><mi mathvariant="normal">∣</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\max{(\sum_{i=1}^{x}{b_i-|a_i-x_{t_i}|})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>.<br>再用瞪眼法, 得出递推式子:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><msub><mi>b</mi><mi>i</mi></msub><mo>−</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><mi>j</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">f[i][j]=\max{(f[i-1][k]+b_i-|a_i-j|)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>:</mo><mi>k</mi><mo>∈</mo><mo stretchy="false">[</mo><msub><mi>x</mi><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></msub><mo>−</mo><mi>d</mi><mo>×</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>−</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>x</mi><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></msub><mo>+</mo><mi>d</mi><mo>×</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>−</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>∩</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">: k\in[x_{t_{i-1}}-d\times(t_i-t_{i-1})),x_{t_{i-1}}+d\times(t_i-t_{i-1}))]\cap [1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><p>时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omicron(n^2m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>.<br>考虑如何优化, 把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>−</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><mi>j</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">b_i-|a_i-j|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>提出.</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><mo>+</mo><msub><mi>b</mi><mi>i</mi></msub><mo>−</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><mi>j</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">f[i][j]=\max{(f[i-1][k])}+b_i-|a_i-j|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><p>发现可以用单调栈均摊, 复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omicron(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>.</p><p>再考虑内存, 可以看出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>的递推式只需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>, 把第一维优化掉.</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1.5e5</span>+<span class="number">5</span>, M = <span class="number">305</span>;</span><br><span class="line">ll a[M], b[M], t[M];</span><br><span class="line">ll f[<span class="number">2</span>][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, d;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;t[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        ll h = (t[i]-t[i<span class="number">-1</span>])*d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>, k=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k&lt;=j+h&amp;&amp;k&lt;=n)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;f[i&amp;<span class="number">1</span>][q.<span class="built_in">back</span>()]&lt;=f[i&amp;<span class="number">1</span>][k]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">                q.<span class="built_in">push_back</span>(k), k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">front</span>()&lt;(j-h)) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            f[!(i&amp;<span class="number">1</span>)][j]=f[i&amp;<span class="number">1</span>][q.<span class="built_in">front</span>()]+b[i]-<span class="built_in">abs</span>(a[i]-j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=-INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(ans, f[!(m&amp;<span class="number">1</span>)][i]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> solution </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solution of USACO12OPEN G(P3067)</title>
      <link href="/2023/03/19/solution-of-USACO12OPEN-G/"/>
      <url>/2023/03/19/solution-of-USACO12OPEN-G/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E9%A2%98%E6%84%8F">题意</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>有可重集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>, 求它的非空子集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>的个数, 满足: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>A</mi><mo>∪</mo><mi>B</mi><mo separator="true">,</mo><mi>A</mi><mo>∪</mo><mi>B</mi><mo>=</mo><mi mathvariant="normal">∅</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><msub><mi>A</mi><mi>i</mi></msub><mo>=</mo><mi mathvariant="normal">Σ</mi><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X=A\cup B, A\cup B=\emptyset, \Sigma A_i=\Sigma B_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>.<br>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">|S| \leq 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">S_i \leq 10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>.</p><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>考虑使用<a href="https://oi-wiki.org/search/bidirectional/">Meet in The Middle思路</a>, 时间复杂度是朴素算法的平方根.<br>一般地, 把集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>分为两部分来搜索, 于是对于每个元素就有了三种分支: 不选, 选入左部分 和 选入右部分.<br>最后进行两部分的合并操作, 关键在于去重.</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">bitset&lt;1&lt;&lt;10&gt; vis[<span class="number">1</span>&lt;&lt;<span class="number">10</span>];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, bitset&lt;1&lt;&lt;10&gt; &gt; mp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> dep, sum, sta;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, mid;</span><br><span class="line">    cin&gt;&gt;n, mid = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">stable_sort</span>(a, a+n);</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(Node&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x =q.<span class="built_in">front</span>().dep, y=q.<span class="built_in">front</span>().sum, z=q.<span class="built_in">front</span>().sta;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x==mid) &#123;</span><br><span class="line">            mp[y].<span class="built_in">set</span>(z);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(Node&#123;x+<span class="number">1</span>, y, z&#125;);</span><br><span class="line">        q.<span class="built_in">push</span>(Node&#123;x+<span class="number">1</span>, y+a[x], z|(<span class="number">1</span>&lt;&lt;x)&#125;);</span><br><span class="line">        q.<span class="built_in">push</span>(Node&#123;x+<span class="number">1</span>, y-a[x], z|(<span class="number">1</span>&lt;&lt;x)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(Node&#123;mid, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x =q.<span class="built_in">front</span>().dep, y=q.<span class="built_in">front</span>().sum, z=q.<span class="built_in">front</span>().sta;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x==n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(y)) &#123;</span><br><span class="line">                bitset&lt;1&lt;&lt;10&gt; <span class="built_in">tmp</span>(mp[y]);</span><br><span class="line">                tmp &amp;=~vis[z], ans+=tmp.<span class="built_in">count</span>(), vis[z]|=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(Node&#123;x+<span class="number">1</span>, y, z&#125;);</span><br><span class="line">        q.<span class="built_in">push</span>(Node&#123;x+<span class="number">1</span>, y+a[x], z|(<span class="number">1</span>&lt;&lt;(x-mid))&#125;);</span><br><span class="line">        q.<span class="built_in">push</span>(Node&#123;x+<span class="number">1</span>, y-a[x], z|(<span class="number">1</span>&lt;&lt;(x-mid))&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> solution </tag>
            
            <tag> USACO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Theorem Proving &amp; Program Verification by Coq</title>
      <link href="/2023/03/06/Theorem-Proving-and-Program-Verification-By-Coq/"/>
      <url>/2023/03/06/Theorem-Proving-and-Program-Verification-By-Coq/</url>
      
        <content type="html"><![CDATA[<h2 id="content"><a class="markdownIt-Anchor" href="#content"></a> Content</h2><ul><li><a href="#content">Content</a></li><li><a href="#introduction">Introduction</a></li><li><a href="#1-proof-equation">1. Proof Equation</a><ul><li><a href="#11-proving-right-inverse-property">1.1 Proving Right Inverse Property</a></li><li><a href="#12-proving-right-unit-property">1.2 Proving Right Unit Property</a></li><li><a href="#13-proving-double-negation-property">1.3 Proving Double Negation Property</a></li></ul></li><li><a href="#2-inductive-type-recursive-definitions-and-inductive-proof">2. Inductive Type, Recursive Definitions and Inductive proof</a></li><li><a href="#%E8%BF%99%E5%87%A0%E5%A4%A9%E4%B8%8D%E5%86%99%E4%BA%86%E5%BE%85%E7%BB%AD"><strong>这几天不写了，待续。。。。</strong></a></li></ul><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><blockquote><p>If we say that programming is through writing code, the combination of simple functions &amp; components to realize the complex assembly, then proof is the combination of some simple proof steps to make the complex proof.<br>Theorem proving tools like Coq &amp; Isabelle allow us to describe mathematical definitions &amp; mathematical proofs in the form of codes.</p></blockquote><p>We use Coq here: <a href="https://github.com/coq/platform/releases/">Coq-Release@github.com</a>. The <a href="https://jscoq.github.io/wa/">online version of Coq</a> is also able to be used.<br>Here is a link to <a href="https://coq.inria.fr/refman/coq-tacindex.html">the official Coq documentation</a> for review &amp; reference, in order for readers’ better reading.<br>This article only guarantees that readers can establish a preliminary understanding of formal theorem proving &amp; program verification. If you’re looking for a book with a richer and more substantial introduction to get familiar with Coq, I recommend you read the <em>“Software Foundations Vol.1: Logical Foundations”</em> at least.</p><h2 id="1-proof-equation"><a class="markdownIt-Anchor" href="#1-proof-equation"></a> 1. Proof Equation</h2><p>Equation is one of the base of math, we started with a proof about group theory.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span> Group.</span><br><span class="line"><span class="keyword">Class</span> GroupOperator: <span class="keyword">Type</span> := &#123;</span><br><span class="line">    tote_set: <span class="keyword">Type</span>;</span><br><span class="line">    zero: tote_set;</span><br><span class="line">    add: tote_set -&gt; tote_set -&gt; tote_set;</span><br><span class="line">    neg: tote_set -&gt; tote_set;</span><br><span class="line">&#125;.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;0&quot;</span> := (zero).</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;a + b&quot;</span> := (add a b).</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;- a&quot;</span> := (neg a).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> <span class="keyword">forall</span> (G: GroupOperator) (x y: tote_set), x + y = y + x.</span><br></pre></td></tr></table></figure><p>First, we have to define which operations a group contains.<br>We can write without these coq-reserve words such as <em>Type or Class</em> here. To define a group operation, you can define the set <em>tote_set</em> first, &amp; then it should contain the unit element <em>zero</em>, the binary operation <em>add</em> &amp; an inverse operation <em>neg</em>.</p><p>The key word <em>Notation</em> in coq helps describe the related properties by using refiner words.</p><p>At the lastest line, the order <em>Check</em> can be understood as asking computer to check if the expression is syntactically legal. The point is that it just does in syntax but not about the proof.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> GroupProperties (G: GroupOperator): <span class="keyword">Prop</span> := &#123;</span><br><span class="line">    associate: <span class="keyword">forall</span> (a b c: tote_set), (a + b) + c = a + (b + c);</span><br><span class="line">    left_unit_clear: <span class="keyword">forall</span> (a: tote_set), <span class="number">0</span> + a = a;</span><br><span class="line">    left_inverstion_clear: <span class="keyword">forall</span> (a: tote_set), (- a) + a = <span class="number">0</span>;</span><br><span class="line">&#125;.</span><br></pre></td></tr></table></figure><p>We list 3 laws of the group, clearing left unit, clearing inverstion &amp; associative law. It 's useful to the next part.</p><h3 id="11-proving-right-inverse-property"><a class="markdownIt-Anchor" href="#11-proving-right-inverse-property"></a> 1.1 Proving Right Inverse Property</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> right_inverstion_clear &#123;G: GroupOperator&#125; &#123;GP: GroupProperties G&#125;: </span><br><span class="line">(<span class="keyword">forall</span> (a: tote_set), a + (- a) = <span class="number">0</span>).</span><br></pre></td></tr></table></figure><p>The things after <em>Theorem</em> here needed to proof by us, Try to do!</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Require</span> <span class="keyword">Import</span> <span class="keyword">Setoid</span>.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> a.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (left_unit_clear (a + (- a))).</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (left_inverstion_clear (- a)) <span class="built_in">at</span> <span class="number">1.</span></span><br><span class="line">  <span class="built_in">rewrite</span> associate.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (associate (- a)).</span><br><span class="line">  <span class="built_in">rewrite</span> left_inverstion_clear.</span><br><span class="line">  <span class="built_in">rewrite</span> left_unit_clear.</span><br><span class="line">  <span class="built_in">rewrite</span> left_inverstion_clear.</span><br><span class="line">  <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure><p>Here is the classical proof in group theory, that’s derived from the two properties of left unit element &amp; left inverse element, to right inverse element.</p><p>We use <em>intros</em> to get the theorem <em>a + (- a) = 0</em> that awaits to be prooved at line 1.<br>Then use the keyword <em>rewrite</em> to convert the existing properties of this equation, the arrow to the left is “&lt;-” means to use properties to transform a certain item of the equation from left to right, the “-&gt;” is opposite operation, followed by the parentheses after the property name Content is used to match corresponding items. If you want to operate only on the matching item at a certain position, you can use the keyword <em>at</em>; if you think that Coq will not cause ambiguity with a certain instruction, you can even ignore the content of the parentheses.<br>Finally, the <em>reflexivity</em> says that the equation is reflexive, &amp; now the equation is exactly the same on both sides, so it’s all of the proof. The <em>Qed.</em> is the end of the <em>Proof.</em> above.We have done all the work of this stupid theorem.</p><p>If you have doubts about a part of this part of the code, please leave it to CoqIDE to run this proof, it will be intuitive to observe the equation change in the goal window on the right. Use the shortcut keys “Ctrl + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↑</mo></mrow><annotation encoding="application/x-tex">\uparrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>” and “Ctrl + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↓</mo></mrow><annotation encoding="application/x-tex">\downarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>” to quickly switch the row up or down.</p><h3 id="12-proving-right-unit-property"><a class="markdownIt-Anchor" href="#12-proving-right-unit-property"></a> 1.2 Proving Right Unit Property</h3><p>Based on the fundamental properties &amp; the results we have proved, it is easy to prove the right unit property corresponding to the left unit property. The right unit property can be expressed as the <em>a + 0 = a</em>.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> right_unit_clear &#123;G: GroupOperator&#125; &#123;GP: GroupProperties G&#125;:</span><br><span class="line">  <span class="keyword">forall</span> (a: tote_set), a + <span class="number">0</span> = a.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span>.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (left_inverstion_clear (a)).</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- associate, right_inverstion_clear, left_unit_clear.</span><br><span class="line">  <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure><p>So it was proven that right unit property. It is possible to write multiple commands together in Coq as in the above code.</p><h3 id="13-proving-double-negation-property"><a class="markdownIt-Anchor" href="#13-proving-double-negation-property"></a> 1.3 Proving Double Negation Property</h3><p>Next prove the double negation signelimination property.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> double_negation &#123;G: GroupOperator&#125; &#123;GP: GroupProperties G&#125;:</span><br><span class="line">  <span class="keyword">forall</span> (a: tote_set), - - a = a.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span>.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (left_unit_clear (--a)).</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (right_inverstion_clear (a)).</span><br><span class="line">  <span class="built_in">rewrite</span> associate, right_inverstion_clear, right_unit_clear.</span><br><span class="line">  <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure><h2 id="2-inductive-type-recursive-definitions-and-inductive-proof"><a class="markdownIt-Anchor" href="#2-inductive-type-recursive-definitions-and-inductive-proof"></a> 2. Inductive Type, Recursive Definitions and Inductive proof</h2><h2 id="这几天不写了待续"><a class="markdownIt-Anchor" href="#这几天不写了待续"></a> <strong>这几天不写了，待续。。。。</strong></h2><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><munderover><mo>∑</mo><munderover><mo>∑</mo><mn>114514</mn><mn>1919810</mn></munderover><munderover><mo>∑</mo><mn>114514</mn><mn>1919810</mn></munderover></munderover><munderover><mo>∑</mo><munderover><mo>∑</mo><mn>114514</mn><mn>1919810</mn></munderover><munderover><mo>∑</mo><mn>114514</mn><mn>1919810</mn></munderover></munderover></munderover></mrow><annotation encoding="application/x-tex">\sum_{\sum_{\sum_{114514}^{1919810}}^{\sum_{114514}^{1919810}}}^{\sum_{\sum_{114514}^{1919810}}^{\sum_{114514}^{1919810}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> coq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome, guest.</title>
      <link href="/2023/03/05/hi-guest/"/>
      <url>/2023/03/05/hi-guest/</url>
      
        <content type="html"><![CDATA[<h2 id="hi"><a class="markdownIt-Anchor" href="#hi"></a> Hi!</h2><p>Welcome to my blog website<br><a href="../../../../about">About this website.</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
