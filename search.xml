<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Theorem Proving &amp; Program Verification by Coq</title>
      <link href="/2023/03/06/Theorem-Proving-and-Program-Verification-By-Coq/"/>
      <url>/2023/03/06/Theorem-Proving-and-Program-Verification-By-Coq/</url>
      
        <content type="html"><![CDATA[<h2 id="content"><a class="markdownIt-Anchor" href="#content"></a> Content</h2><ul><li><a href="#content">Content</a></li><li><a href="#introduction">Introduction</a></li><li><a href="#1-proof-equation">1. Proof Equation</a><ul><li><a href="#11-proving-right-inverse-property">1.1 Proving Right Inverse Property</a></li><li><a href="#12-proving-right-unit-property">1.2 Proving Right Unit Property</a></li><li><a href="#13-proving-double-negation-property">1.3 Proving Double Negation Property</a></li></ul></li><li><a href="#2-inductive-type-recursive-definitions-and-inductive-proof">2. Inductive Type, Recursive Definitions and Inductive proof</a></li><li><a href="#%E8%BF%99%E5%87%A0%E5%A4%A9%E4%B8%8D%E5%86%99%E4%BA%86%E5%BE%85%E7%BB%AD"><strong>这几天不写了，待续。。。。</strong></a></li></ul><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><blockquote><p>If we say that programming is through writing code, the combination of simple functions &amp; components to realize the complex assembly, then proof is the combination of some simple proof steps to make the complex proof.<br />Theorem proving tools like Coq &amp; Isabelle allow us to describe mathematical definitions &amp; mathematical proofs in the form of codes.</p></blockquote><p>We use Coq here: <a href="https://github.com/coq/platform/releases/">Coq-Release@github.com</a>. The <a href="https://jscoq.github.io/wa/">online version of Coq</a> is also able to be used.</p><h2 id="1-proof-equation"><a class="markdownIt-Anchor" href="#1-proof-equation"></a> 1. Proof Equation</h2><p>Equation is one of the base of math, we started with a proof about group theory.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Module</span> Group.</span><br><span class="line"><span class="keyword">Class</span> GroupOperator: <span class="keyword">Type</span> := &#123;</span><br><span class="line">    tote_set: <span class="keyword">Type</span>;</span><br><span class="line">    zero: tote_set;</span><br><span class="line">    add: tote_set -&gt; tote_set -&gt; tote_set;</span><br><span class="line">    neg: tote_set -&gt; tote_set;</span><br><span class="line">&#125;.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;0&quot;</span> := (zero).</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;a + b&quot;</span> := (add a b).</span><br><span class="line"><span class="keyword">Notation</span> <span class="string">&quot;- a&quot;</span> := (neg a).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Check</span> <span class="keyword">forall</span> (G: GroupOperator) (x y: tote_set), x + y = y + x.</span><br></pre></td></tr></table></figure><p>First, we have to define which operations a group contains.<br />We can write without these coq-reserve words such as <em>Type or Class</em> here. To define a group operation, you can define the set <em>tote_set</em> first, &amp; then it should contain the unit element <em>zero</em>, the binary operation <em>add</em> &amp; an inverse operation <em>neg</em>.</p><p>The key word <em>Notation</em> in coq helps describe the related properties by using refiner words.</p><p>At the lastest line, the order <em>Check</em> can be understood as asking computer to check if the expression is syntactically legal. The point is that it just does in syntax but not about the proof.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> GroupProperties (G: GroupOperator): <span class="keyword">Prop</span> := &#123;</span><br><span class="line">    associate: <span class="keyword">forall</span> (a b c: tote_set), (a + b) + c = a + (b + c);</span><br><span class="line">    left_unit_clear: <span class="keyword">forall</span> (a: tote_set), <span class="number">0</span> + a = a;</span><br><span class="line">    left_inverstion_clear: <span class="keyword">forall</span> (a: tote_set), (- a) + a = <span class="number">0</span>;</span><br><span class="line">&#125;.</span><br></pre></td></tr></table></figure><p>We list 3 laws of the group, clearing left unit, clearing inverstion &amp; associative law. It 's useful to the next part.</p><h3 id="11-proving-right-inverse-property"><a class="markdownIt-Anchor" href="#11-proving-right-inverse-property"></a> 1.1 Proving Right Inverse Property</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> right_inverstion_clear &#123;G: GroupOperator&#125; &#123;GP: GroupProperties G&#125;: </span><br><span class="line">(<span class="keyword">forall</span> (a: tote_set), a + (- a) = <span class="number">0</span>).</span><br></pre></td></tr></table></figure><p>The things after <em>Theorem</em> here needed to proof by us, Try to do!</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Require</span> <span class="keyword">Import</span> <span class="keyword">Setoid</span>.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> a.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (left_unit_clear (a + (- a))).</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (left_inverstion_clear (- a)) <span class="built_in">at</span> <span class="number">1.</span></span><br><span class="line">  <span class="built_in">rewrite</span> associate.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (associate (- a)).</span><br><span class="line">  <span class="built_in">rewrite</span> left_inverstion_clear.</span><br><span class="line">  <span class="built_in">rewrite</span> left_unit_clear.</span><br><span class="line">  <span class="built_in">rewrite</span> left_inverstion_clear.</span><br><span class="line">  <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure><p>Here is the classical proof in group theory, that’s derived from the two properties of left unit element &amp; left inverse element, to right inverse element.</p><p>We use <em>intros</em> to get the theorem <em>a + (- a) = 0</em> that awaits to be prooved at line 1.<br />Then use the keyword <em>rewrite</em> to convert the existing properties of this equation, the arrow to the left is “&lt;-” means to use properties to transform a certain item of the equation from left to right, the “-&gt;” is opposite operation, followed by the parentheses after the property name Content is used to match corresponding items. If you want to operate only on the matching item at a certain position, you can use the keyword <em>at</em>; if you think that Coq will not cause ambiguity with a certain instruction, you can even ignore the content of the parentheses.<br />Finally, the <em>reflexivity</em> says that the equation is reflexive, &amp; now the equation is exactly the same on both sides, so it’s all of the proof. The <em>Qed.</em> is the end of the <em>Proof.</em> above.We have done all the work of this stupid theorem.</p><p>If you have doubts about a part of this part of the code, please leave it to CoqIDE to run this proof, it will be intuitive to observe the equation change in the goal window on the right. Use the shortcut keys “Ctrl + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↑</mo></mrow><annotation encoding="application/x-tex">\uparrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>” and “Ctrl + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↓</mo></mrow><annotation encoding="application/x-tex">\downarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>” to quickly switch the row up or down.</p><h3 id="12-proving-right-unit-property"><a class="markdownIt-Anchor" href="#12-proving-right-unit-property"></a> 1.2 Proving Right Unit Property</h3><p>Based on the fundamental properties &amp; the results we have proved, it is easy to prove the right unit property corresponding to the left unit property. The right unit property can be expressed as the <em>a + 0 = a</em>.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> right_unit_clear &#123;G: GroupOperator&#125; &#123;GP: GroupProperties G&#125;:</span><br><span class="line">  <span class="keyword">forall</span> (a: tote_set), a + <span class="number">0</span> = a.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span>.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (left_inverstion_clear (a)).</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- associate, right_inverstion_clear, left_unit_clear.</span><br><span class="line">  <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure><p>So it was proven that right unit property. It is possible to write multiple commands together in Coq as in the above code.</p><h3 id="13-proving-double-negation-property"><a class="markdownIt-Anchor" href="#13-proving-double-negation-property"></a> 1.3 Proving Double Negation Property</h3><p>Next prove the double negation signelimination property.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> double_negation &#123;G: GroupOperator&#125; &#123;GP: GroupProperties G&#125;:</span><br><span class="line">  <span class="keyword">forall</span> (a: tote_set), - - a = a.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span>.</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (left_unit_clear (--a)).</span><br><span class="line">  <span class="built_in">rewrite</span> &lt;- (right_inverstion_clear (a)).</span><br><span class="line">  <span class="built_in">rewrite</span> associate, right_inverstion_clear, right_unit_clear.</span><br><span class="line">  <span class="built_in">reflexivity</span>.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure><h2 id="2-inductive-type-recursive-definitions-and-inductive-proof"><a class="markdownIt-Anchor" href="#2-inductive-type-recursive-definitions-and-inductive-proof"></a> 2. Inductive Type, Recursive Definitions and Inductive proof</h2><h2 id="这几天不写了待续"><a class="markdownIt-Anchor" href="#这几天不写了待续"></a> <strong>这几天不写了，待续。。。。</strong></h2><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><munderover><mo>∑</mo><munderover><mo>∑</mo><mn>114514</mn><mn>1919810</mn></munderover><munderover><mo>∑</mo><mn>114514</mn><mn>1919810</mn></munderover></munderover><munderover><mo>∑</mo><munderover><mo>∑</mo><mn>114514</mn><mn>1919810</mn></munderover><munderover><mo>∑</mo><mn>114514</mn><mn>1919810</mn></munderover></munderover></munderover></mrow><annotation encoding="application/x-tex">\sum_{\sum_{\sum_{114514}^{1919810}}^{\sum_{114514}^{1919810}}}^{\sum_{\sum_{114514}^{1919810}}^{\sum_{114514}^{1919810}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> coq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome, guest.</title>
      <link href="/2023/03/05/hi-guest/"/>
      <url>/2023/03/05/hi-guest/</url>
      
        <content type="html"><![CDATA[<h2 id="hi"><a class="markdownIt-Anchor" href="#hi"></a> Hi!</h2><p>Welcome to my blog website<br /><a href="../../../../about">About this website.</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
