[{"categories":null,"contents":"This blog website was originally created several years ago when I was in high school. Initially, it hosted a collection of articles I casually wrote about algorithm competitions. However, I later discovered that the website had poor support for LaTeX, with some formula subscripts misaligned in Chrome. Due to time constraints, I never got around to fixing it. Now, on March 6, 2025, after a thorough reorganization, the website stands in its current form.\nThe texts below is from the initial version of this website.\nHowdy! Welcome to my blog website! Some diurnal, practise, ruminate \u0026amp; comprehend of myself will be put here. See at Articles.\nMe A student who is interested in algorithms and mathematics. You can find me through these links below.\nMail: JiansYuan@outlook.com\nGithub: Contexploit\nZhihu: JiansYuan\n","date":"2025-03-06T00:00:00Z","permalink":"https://jiansyuan.github.io/about/","section":"","tags":null,"title":"About"},{"categories":["Algorithms"],"contents":"先决知识 基本的图论和数据结构知识 线段树(Segment Tree) DFS序(Depth-first-search SEQ.) 基本思想 树链剖分(Tree Chain Partition)的思路是将一整颗树剖分若干条链, 组合这些链成为线性结构从而能使用其他数据结构维护信息.具体地, 按照判链条件来讲有多种剖分方式, 如重链剖分, 长链剖分以及实链剖分. 本文要介绍被广泛运用的重链剖分.\n重链剖分以子树的大小为依据来确定该子树的根节点是否在链上, 链的数量不超过 $\\log_2N$ 条. 链在树的结构上是延续的, 一条链中的每一个节点所映射到的线性结构上的标号也是延续的. 这样能实现 $\\Omicron(\\log_2N)$ 级别的任意两点之间的查询树上路径和, 树上路径极值等, 以及对树上单点或区间值的修改操作.\n给出定义 重子节点(重儿子): 对于一个节点的所有子节点中, 所有子树的节点最多的那一个子节点. 轻子节点(轻儿子): 对于一个节点的所有子节点中, 所有不是重子节点的其他子节点. 重边: 一条边中如果深度更深的节点是重子节点, 那这条边就叫重边. 轻边: 所有不是重边的边. 重链: 由一或多条重边连接成的延续的路径. 轻链: 所有不是重链的链. 如图, 在这一颗树中, 被以红色填充的点是重子节点, 额外被两条红线标记的边是重边. 该图符合上文给出的定义, 可以看出图上存在三条重链.\n过程分析 我们首先通过两次的 $DFS$ 来计算出一些信息.\nDFS_1 给出以下伪代码:\n这段代码处理了每个节点的 $father, heavy_son, depth, size$ 这些信息, 其中 $size$ 是以这个点为根的子树的点数量.\nDFS_2 这段代码处理出每个点映射到线性结构上对应的标号 $index$ 和线性结构每个标号对应到的点 $new_id$. 还按照定义处理出重子节点 $heavy_son$, 以及重链链头信息 $top$.\n线段树 随后就能根据 $new_id$ 建出一颗线段树, 提供对区间求和的更新和查询操作. 这是一个很自然的过程, 不多赘述.\n路径查询/修改 和常规的倍增 $LCA$ 操作思想类似, 如下:\n如果两点在同一重链上 (链头相同), 答案加上两点 $index$ 在线段树上的区间和, 结束。 否则, 对于深度更深的点, 答案加上链头和当前 $index$ 在线段树上区间和, 跳到所在链头上, 一直如此直到在同一条重链上执行才执行上面的操作. 这里是因为链上连续节点在线性结构上连续的性质. 类似地, 路径修改就是把上面的线段树操作换成区间修改.\n子树查询/修改 从前面的$DFS_2$ 可以发现, 重链抛分同样具有 $DFS$ 序的子树连续性质. 所以说只要作一次线段树上的区间查询或者修改操作就行了.\n参考实现 LGP3384 模板题 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6+5; int n, m, r, p, cnt=0, num[N], hes[N], siz[N], fat[N], dep[N], top[N], idx[N], nid[N]; vector\u0026lt;int\u0026gt; g[N]; int dfs1(int rt, int fa, int deep){ fat[rt]=fa, siz[rt]=1, dep[rt]=deep; for(auto i : g[rt]){ if(i==fa) continue; siz[rt]+=dfs1(i, rt, deep+1), hes[rt]=siz[hes[rt]]\u0026gt;siz[i]?hes[rt]:i; } return siz[rt]; } void dfs2(int rt, int tp){ idx[rt]=++cnt, nid[cnt]=num[rt], top[rt]=tp; if(hes[rt]) dfs2(hes[rt], tp); for(auto i : g[rt]) if(i!=fat[rt] \u0026amp;\u0026amp; i!=hes[rt]) dfs2(i, i); } //Start Segment Tree here... struct Tree{ int sum, laz, len; }tre[N]; #define l(a) (a\u0026lt;\u0026lt;1) #define r(a) (a\u0026lt;\u0026lt;1|1) #define push_up(a) tre[rt].sum = tre[l(rt)].sum+tre[r(rt)].sum void build_tree(int l, int r, int rt){ tre[rt].len = r-l+1; if(l==r) { tre[rt].sum=nid[l]; return ;} int mid = (l+r)\u0026gt;\u0026gt;1; build_tree(l, mid, l(rt)), build_tree(mid+1, r, r(rt)), push_up(rt); } inline void push_down(int rt){ if(!tre[rt].laz) return; tre[l(rt)].laz+=tre[rt].laz, tre[l(rt)].laz%=p; tre[r(rt)].laz+=tre[rt].laz, tre[r(rt)].laz%=p; tre[l(rt)].sum+=tre[rt].laz*tre[l(rt)].len, tre[l(rt)].sum%=p; tre[r(rt)].sum+=tre[rt].laz*tre[r(rt)].len, tre[r(rt)].sum%=p, tre[rt].laz=0; } void update_tree(int stdl, int stdr, int l, int r, int rt, int val){ if(stdl\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=stdr){ tre[rt].sum += tre[rt].len*val%p, tre[rt].sum%=p, tre[rt].laz+=val; return; } push_down(rt); int mid = (l+r)\u0026gt;\u0026gt;1; if(stdl\u0026lt;=mid) update_tree(stdl, stdr, l, mid, l(rt), val); if(mid+1\u0026lt;=stdr) update_tree(stdl, stdr, mid+1, r, r(rt), val); push_up(rt); } int query_tree(int stdl, int stdr, int l, int r, int rt){ if(stdl\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=stdr) return tre[rt].sum; push_down(rt); int mid = (l+r)\u0026gt;\u0026gt;1, ret=0; if(stdl\u0026lt;=mid) ret+=query_tree(stdl, stdr, l, mid, l(rt)); if(mid+1\u0026lt;=stdr) ret+=query_tree(stdl, stdr, mid+1, r, r(rt)); return (ret+p)%p; } void update_chain(int x, int y, int val){ int tmpx = top[x], tmpy = top[y]; while(tmpx != tmpy){ if(dep[tmpx]\u0026lt;dep[tmpy]) swap(x, y), swap(tmpx, tmpy); update_tree(idx[tmpx], idx[x], 1, cnt, 1, val); x = fat[tmpx], tmpx = top[x]; } if(idx[x] \u0026gt; idx[y]) swap(x, y); update_tree(idx[x], idx[y], 1 ,cnt, 1, val); } int query_chain(int x, int y){ int ret=0, tmpx=top[x], tmpy=top[y]; while(tmpx != tmpy){ if(dep[tmpx]\u0026lt;dep[tmpy]) swap(x, y), swap(tmpx, tmpy); ret += query_tree(idx[tmpx], idx[x], 1, cnt, 1); x = fat[tmpx], tmpx = top[x]; } if(idx[x]\u0026gt;idx[y]) swap(x, y); return (ret + query_tree(idx[x], idx[y], 1, cnt, 1) + p)%p; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;r\u0026gt;\u0026gt;p; for(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;num[i], num[i]%=p; for(int i=1, x, y;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y, g[x].push_back(y), g[y].push_back(x); dfs1(r, -114514, 0), dfs2(r, r), build_tree(1, n, 1); while(m--){ int opt, x, y, z; cin\u0026gt;\u0026gt;opt; if(opt==1) cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z, update_chain(x, y, z); else if(opt==2) cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y, cout\u0026lt;\u0026lt;query_chain(x, y)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; else if(opt==3) cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y, update_tree(idx[x], idx[x]+siz[x]-1, 1, n, 1, y); else if(opt==4) cin\u0026gt;\u0026gt;x, cout\u0026lt;\u0026lt;query_tree(idx[x], idx[x]+siz[x]-1, 1, n, 1)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } LGP3178/HAOI2015 \u0026ldquo;树上操作\u0026rdquo; #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N = 1e6+5; int n, m, cnt=0, num[N], hes[N], siz[N], fat[N], dep[N], top[N], idx[N], nid[N]; vector\u0026lt;int\u0026gt; g[N]; int dfs1(int rt, int fa, int deep){ fat[rt]=fa, siz[rt]=1, dep[rt]=deep; for(auto i : g[rt]){ if(i==fa) continue; siz[rt]+=dfs1(i, rt, deep+1), hes[rt]=siz[hes[rt]]\u0026gt;siz[i]?hes[rt]:i; } return siz[rt]; } void dfs2(int rt, int tp){ idx[rt]=++cnt, nid[cnt]=num[rt], top[rt]=tp; if(hes[rt]) dfs2(hes[rt], tp); for(auto i : g[rt]) if(i!=fat[rt] \u0026amp;\u0026amp; i!=hes[rt]) dfs2(i, i); } //Start Segment Tree here... struct Tree{ int sum, laz, len; }tre[N]; #define l(a) (a\u0026lt;\u0026lt;1) #define r(a) (a\u0026lt;\u0026lt;1|1) #define push_up(a) tre[rt].sum = tre[l(rt)].sum+tre[r(rt)].sum void build_tree(int l, int r, int rt){ tre[rt].len = r-l+1; if(l==r) { tre[rt].sum=nid[l]; return ;} int mid = (l+r)\u0026gt;\u0026gt;1; build_tree(l, mid, l(rt)), build_tree(mid+1, r, r(rt)), push_up(rt); } inline void push_down(int rt){ if(!tre[rt].laz) return; tre[l(rt)].laz+=tre[rt].laz; tre[r(rt)].laz+=tre[rt].laz; tre[l(rt)].sum+=tre[rt].laz*tre[l(rt)].len; tre[r(rt)].sum+=tre[rt].laz*tre[r(rt)].len, tre[rt].laz=0; } void update_tree(int stdl, int stdr, int l, int r, int rt, int val){ if(stdl\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=stdr){ tre[rt].sum += tre[rt].len*val, tre[rt].laz+=val; return; } push_down(rt); int mid = (l+r)\u0026gt;\u0026gt;1; if(stdl\u0026lt;=mid) update_tree(stdl, stdr, l, mid, l(rt), val); if(mid+1\u0026lt;=stdr) update_tree(stdl, stdr, mid+1, r, r(rt), val); push_up(rt); } int query_tree(int stdl, int stdr, int l, int r, int rt){ if(stdl\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=stdr) return tre[rt].sum; push_down(rt); int mid = (l+r)\u0026gt;\u0026gt;1, ret=0; if(stdl\u0026lt;=mid) ret+=query_tree(stdl, stdr, l, mid, l(rt)); if(mid+1\u0026lt;=stdr) ret+=query_tree(stdl, stdr, mid+1, r, r(rt)); return (ret); } void update_chain(int x, int y, int val){ int tmpx = top[x], tmpy = top[y]; while(tmpx != tmpy){ if(dep[tmpx]\u0026lt;dep[tmpy]) swap(x, y), swap(tmpx, tmpy); update_tree(idx[tmpx], idx[x], 1, cnt, 1, val); x = fat[tmpx], tmpx = top[x]; } if(idx[x] \u0026gt; idx[y]) swap(x, y); update_tree(idx[x], idx[y], 1 ,cnt, 1, val); } int query_chain(int x, int y){ int ret=0, tmpx=top[x], tmpy=top[y]; while(tmpx != tmpy){ if(dep[tmpx]\u0026lt;dep[tmpy]) swap(x, y), swap(tmpx, tmpy); ret += query_tree(idx[tmpx], idx[x], 1, cnt, 1); x = fat[tmpx], tmpx = top[x]; } if(idx[x]\u0026gt;idx[y]) swap(x, y); return ret + query_tree(idx[x], idx[y], 1, cnt, 1); } signed main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;num[i]; for(int i=1, x, y;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y, g[x].push_back(y), g[y].push_back(x); dfs1(1, -114514, 0), dfs2(1, 1), build_tree(1, n, 1); while(m--){ int opt, x, y, z; cin\u0026gt;\u0026gt;opt; if(opt==1) cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y, update_tree(idx[x], idx[x], 1, n, 1, y); else if(opt==2) cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y, update_tree(idx[x], idx[x]+siz[x]-1, 1, n, 1, y); else cin\u0026gt;\u0026gt;x, cout\u0026lt;\u0026lt;query_chain(1, x)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } ","date":"2023-03-26T00:00:00Z","permalink":"https://jiansyuan.github.io/post/talk-about-tree-chain-partition/","section":"post","tags":["Tutorial","Graph Theory"],"title":"Talk about Tree Chain Partition"},{"categories":["Algorithms"],"contents":"题意 今天不想简化题面。。。\nP 教授要去看奥运，但是他舍不得他的玩具，于是他决定把所有的玩具运到北京。\n他使用自己的压缩器进行压缩。这个压缩器可以将任意物品变成一维，再放到一种特殊的一维容器中。P 教授有编号为 $1\\dots n$ 的 $n$ 件玩具，玩具经过压缩后会变成一维，第 $i$ 件件玩具压缩后长度为 $C_i$。\n为了方便整理，P 教授要求：\n在一个一维容器中，玩具的编号是连续的； 如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果要将 $i$ 号玩具到 $j$ 号玩具放到同一个容器中，则容器长度不小于 $x=j-i+\\sum_{k=i}^{j}C_k$。 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$，其中 $L$ 是一个常量。\nP 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。试求最小费用。\n数据范围：$1\\le n\\le 5\\times 10^4$，$1\\le L,C_i\\le 10^7$\n思路 DP : 斜率优化+单调队列\n朴素的解法 令$ans[i]$为选到第$i$个玩具时的最小费用, 列出朴素的状态转移方程: $$ ans[i]=\\min_{0\\le j\u0026lt;i}{(ans[j]+(i-j-1-L+\\Sigma_{k=j+1}^iC_k)^2)} $$ 如果$sum[i]=\\sum_{j=0}^iC_j$ : $$ ans[i]=\\min_{0\\le j\u0026lt;i}{(ans[j]+(i-j-1-L+sum[i]-sum[j])^2)} $$ 然后复杂度是$\\Omicron(n^2)$, 呜呜呜到底要怎么办呢.\n先把式子化简, 令$f[i]=sum[i]+i$ 和 $L\u0026rsquo;=L+1$, 就有了: $$ ans[i]=\\min_{0\\le j\u0026lt;i}{(ans[j]+(f[i]-f[j]-L^{\\prime})^2)} $$\n斜率方程 把和$j$无关的项移到左侧:\n$$ ans[i]-(f[i]-L\u0026rsquo;)^2=\\min_{0\\le j\u0026lt;i}{{ans[j]+f[j]^2+2f[j] (L\u0026rsquo;-f[i])}} $$\n把一次函数的斜截式$y=kx+b$移动得到$y-kx=b$. 发现可以这样表示: $$ \\begin{aligned} x_j=\u0026amp;f[j]\\\\ y_j=\u0026amp;ans[j]+f[j]^2\\\\ k_i=\u0026amp;-2(L\u0026rsquo;-f[i])\\\\ b_i=\u0026amp;ans[i]-(f[i]-L\u0026rsquo;)^2\\\\ \\end{aligned} $$ 所以转移方程也就是: $$ b_i=\\min_{0\\le j\u0026lt;i}{(y_j-k_ix_j)} $$ 其实就是求直线最小的截率$b_i$. 显然地, 答案在点集${(x_i, y_i)}$的下凸壳上, 具有决策单调性, 请自行证明.\n代码 const int N = 5e4+5; ll n, L, f[N], ans[N], qu[N], hd, tl; #define pow2(a) pow(a, 2) inline double slope(ll x, ll y){ return (double)((ans[y]+pow2(f[y]+L))-(ans[x]+pow2(f[x]+L)))/(2.0*(f[y]-f[x])); } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;L, L++; for(int i=1, tmp;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;tmp, f[i]=f[i-1]+tmp+1; for(int i=1;i\u0026lt;=n;i++){ while(hd\u0026lt;tl\u0026amp;\u0026amp;slope(qu[hd], qu[hd+1])\u0026lt;=f[i]) hd++; ans[i]=ans[qu[hd]]+pow2(f[i]-f[qu[hd]]-L); while(hd\u0026lt;tl\u0026amp;\u0026amp;slope(qu[tl], i)\u0026lt;slope(qu[tl-1], qu[tl])) tl--; qu[++tl]=i; } cout\u0026lt;\u0026lt;ans[n]\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-03-22T00:00:00Z","permalink":"https://jiansyuan.github.io/post/solution-of-hnoi2008-pack-toys/","section":"post","tags":["Solution","HNOI","DP"],"title":"Solution of HNOI2008 “玩具装箱”(P3195)"},{"categories":["Algorithms"],"contents":"题意 有 $n$ 个相邻 距离为 $1$ 的地点编号为 $1-n$. 有 $m$ 个事件分别在地点 $a_i$ 时间 $t_i$ 发生, 在 $t_i$ 时位于地点 $x_{t_i}$ 能获得 $b_i-|a_i-x_{t_i}|$ 的收益, 要求 $|x_i-x_{i+1}|\\le d$. 求 $\\max{(\\sum{b_i-|a_i-x_{t_i}|})}$.\n其中 $1\\le n\\le 150000, 1\\le m\\le 300, 1\\le d\\le n$;\n$1\\le a_i\\le n, 1\\le b_i\\le 10^9, 1\\le t_i\\le 10^9$.\n思路 考虑 DP. 先令 $f[x][y]$ 为 $x_{t_x}=y$ 情况下的 $\\max{(\\sum_{i=1}^{x}{b_i-|a_i-x_{t_i}|})}$. 再用瞪眼法, 得出递推式子: $$ f[i][j]=\\max{(f[i-1][k]+b_i-|a_i-j|)} \\\\ :k\\in[x_{t_{i-1}}-d\\times(t_i-t_{i-1})),x_{t_{i-1}}+d\\times(t_i-t_{i-1}))]\\cap [1,n] $$\n时间复杂度是 $\\Omicron(n^2m)$. 考虑如何优化, 把 $b_i-|a_i-j|$ 提出. $$ f[i][j]=\\max{(f[i-1][k])}+b_i-|a_i-j| $$ 发现可以用单调栈均摊, 复杂度 $\\Omicron(nm)$.\n再考虑内存, 可以看出 $f[i][j]$ 的递推式只需要 $f[i-1][j]$, 把第一维优化掉.\n代码 #define ll long long const int N = 1.5e5+5, M = 305; ll a[M], b[M], t[M]; ll f[2][N]={0}; int main(){ int n, m, d; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;d; for(int i=1;i\u0026lt;=m;i++) cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;t[i]; for(int i=1;i\u0026lt;=m;i++){ deque\u0026lt;int\u0026gt; q; ll h = (t[i]-t[i-1])*d; for(int j=1, k=1;j\u0026lt;=n;j++){ while(k\u0026lt;=j+h\u0026amp;\u0026amp;k\u0026lt;=n){ while(!q.empty()\u0026amp;\u0026amp;f[i\u0026amp;1][q.back()]\u0026lt;=f[i\u0026amp;1][k]) q.pop_back(); q.push_back(k), k++; } while(!q.empty()\u0026amp;\u0026amp;q.front()\u0026lt;(j-h)) q.pop_front(); f[!(i\u0026amp;1)][j]=f[i\u0026amp;1][q.front()]+b[i]-abs(a[i]-j); } } ll ans=-INT_MAX; for(int i=1;i\u0026lt;=n;i++) ans=max(ans, f[!(m\u0026amp;1)][i]); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-03-21T00:00:00Z","permalink":"https://jiansyuan.github.io/post/solution-of-cf372c/","section":"post","tags":["Solution","Codeforces","DP"],"title":"Solution of Codeforces372 C"},{"categories":["Algorithms"],"contents":"题意 有可重集$S$, 求它的非空子集$X$的个数, 满足: $X=A\\cup B, A\\cup B=\\emptyset, \\Sigma A_i=\\Sigma B_i$. 其中$|S| \\leq 20$, $S_i \\leq 10^8$.\n思路 考虑使用Meet in The Middle思路, 时间复杂度是朴素算法的平方根. 一般地, 把集合$S$分为两部分来搜索, 于是对于每个元素就有了三种分支: 不选, 选入左部分 和 选入右部分. 最后进行两部分的合并操作, 关键在于去重.\n代码 const int N = 30; int a[N]; bitset\u0026lt;1\u0026lt;\u0026lt;10\u0026gt; vis[1\u0026lt;\u0026lt;10]; unordered_map\u0026lt;int, bitset\u0026lt;1\u0026lt;\u0026lt;10\u0026gt; \u0026gt; mp; struct Node{ int dep, sum, sta; }; int main(){ int n, mid; cin\u0026gt;\u0026gt;n, mid = n\u0026gt;\u0026gt;1; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i]; stable_sort(a, a+n); queue\u0026lt;Node\u0026gt; q; q.push(Node{0, 0, 0}); while(!q.empty()){ int x =q.front().dep, y=q.front().sum, z=q.front().sta; q.pop(); if(x==mid) { mp[y].set(z); continue; } q.push(Node{x+1, y, z}); q.push(Node{x+1, y+a[x], z|(1\u0026lt;\u0026lt;x)}); q.push(Node{x+1, y-a[x], z|(1\u0026lt;\u0026lt;x)}); } q.push(Node{mid, 0, 0}); int ans=0; while(!q.empty()){ int x =q.front().dep, y=q.front().sum, z=q.front().sta; q.pop(); if(x==n){ if(mp.count(y)) { bitset\u0026lt;1\u0026lt;\u0026lt;10\u0026gt; tmp(mp[y]); tmp \u0026amp;=~vis[z], ans+=tmp.count(), vis[z]|=tmp; } continue; } q.push(Node{x+1, y, z}); q.push(Node{x+1, y+a[x], z|(1\u0026lt;\u0026lt;(x-mid))}); q.push(Node{x+1, y-a[x], z|(1\u0026lt;\u0026lt;(x-mid))}); } cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; } ","date":"2023-03-19T00:00:00Z","permalink":"https://jiansyuan.github.io/post/solution-of-usaco12open-g/","section":"post","tags":["Solution","USACO"],"title":"Solution of USACO12OPEN G(P3067)"},{"categories":["Program Verification"],"contents":" ⚠ WARN： During my reorganization of the website, I encountered this article and discovered that it appears to have been left unfinished several years ago. Introduction If we say that programming is through writing code, the combination of simple functions \u0026amp; components to realize the complex assembly, then proof is the combination of some simple proof steps to make the complex proof. Theorem proving tools like Coq \u0026amp; Isabelle allow us to describe mathematical definitions \u0026amp; mathematical proofs in the form of codes.\nWe use Coq here: Coq-Release@github.com. The online version of Coq is also able to be used. Here is a link to the official Coq documentation for review \u0026amp; reference, in order for readers\u0026rsquo; better reading. This article only guarantees that readers can establish a preliminary understanding of formal theorem proving \u0026amp; program verification. If you\u0026rsquo;re looking for a book with a richer and more substantial introduction to get familiar with Coq, I recommend you read the \u0026ldquo;Software Foundations Vol.1: Logical Foundations\u0026rdquo; at least.\n1. Proof Equation Equation is one of the base of math, we started with a proof about group theory.\nModule Group. Class GroupOperator: Type := { tote_set: Type; zero: tote_set; add: tote_set -\u0026gt; tote_set -\u0026gt; tote_set; neg: tote_set -\u0026gt; tote_set; }. Notation \u0026#34;0\u0026#34; := (zero). Notation \u0026#34;a + b\u0026#34; := (add a b). Notation \u0026#34;- a\u0026#34; := (neg a). Check forall (G: GroupOperator) (x y: tote_set), x + y = y + x. First, we have to define which operations a group contains. We can write without these coq-reserve words such as Type or Class here. To define a group operation, you can define the set tote_set first, \u0026amp; then it should contain the unit element zero, the binary operation add \u0026amp; an inverse operation neg.\nThe key word Notation in coq helps describe the related properties by using refiner words.\nAt the lastest line, the order Check can be understood as asking computer to check if the expression is syntactically legal. The point is that it just does in syntax but not about the proof.\nClass GroupProperties (G: GroupOperator): Prop := { associate: forall (a b c: tote_set), (a + b) + c = a + (b + c); left_unit_clear: forall (a: tote_set), 0 + a = a; left_inverstion_clear: forall (a: tote_set), (- a) + a = 0; }. We list 3 laws of the group, clearing left unit, clearing inverstion \u0026amp; associative law. It \u0026rsquo;s useful to the next part.\n1.1 Proving Right Inverse Property Theorem right_inverstion_clear {G: GroupOperator} {GP: GroupProperties G}: (forall (a: tote_set), a + (- a) = 0). The things after Theorem here needed to proof by us, Try to do!\nRequire Import Setoid. Proof. intros a. rewrite \u0026lt;- (left_unit_clear (a + (- a))). rewrite \u0026lt;- (left_inverstion_clear (- a)) at 1. rewrite associate. rewrite \u0026lt;- (associate (- a)). rewrite left_inverstion_clear. rewrite left_unit_clear. rewrite left_inverstion_clear. reflexivity. Qed. Here is the classical proof in group theory, that\u0026rsquo;s derived from the two properties of left unit element \u0026amp; left inverse element, to right inverse element.\nWe use intros to get the theorem a + (- a) = 0 that awaits to be prooved at line 1. Then use the keyword rewrite to convert the existing properties of this equation, the arrow to the left is \u0026lt;- means to use properties to transform a certain item of the equation from left to right, the -\u0026gt; is opposite operation, followed by the parentheses after the property name Content is used to match corresponding items. If you want to operate only on the matching item at a certain position, you can use the keyword at; if you think that Coq will not cause ambiguity with a certain instruction, you can even ignore the content of the parentheses. Finally, the reflexivity. says that the equation is reflexive, \u0026amp; now the equation is exactly the same on both sides, so it\u0026rsquo;s all of the proof. The Qed. is the end of the Proof. above. We have done all the work of this stupid theorem.\nIf you have doubts about a part of this part of the code, please leave it to CoqIDE to run this proof, it will be intuitive to observe the equation change in the goal window on the right. Use the shortcut keys \u0026ldquo;Ctrl + $\\uparrow$\u0026rdquo; and \u0026ldquo;Ctrl + $\\downarrow$\u0026rdquo; to quickly switch the row up or down.\n1.2 Proving Right Unit Property Based on the fundamental properties \u0026amp; the results we have proved, it is easy to prove the right unit property corresponding to the left unit property. The right unit property can be expressed as the a + 0 = a.\nTheorem right_unit_clear {G: GroupOperator} {GP: GroupProperties G}: forall (a: tote_set), a + 0 = a. Proof. intros. rewrite \u0026lt;- (left_inverstion_clear (a)). rewrite \u0026lt;- associate, right_inverstion_clear, left_unit_clear. reflexivity. Qed. So it was proven that right unit property. It is possible to write multiple commands together in Coq as in the above code.\n1.3 Proving Double Negation Property Next prove the double negation signelimination property.\nTheorem double_negation {G: GroupOperator} {GP: GroupProperties G}: forall (a: tote_set), - - a = a. Proof. intros. rewrite \u0026lt;- (left_unit_clear (--a)). rewrite \u0026lt;- (right_inverstion_clear (a)). rewrite associate, right_inverstion_clear, right_unit_clear. reflexivity. Qed. 2. Inductive Type, Recursive Definitions and Inductive proof 这几天不写了，待续。。。。 $$ \\sum_{\\sum_{\\sum_{114514}^{1919810}}^{\\sum_{114514}^{1919810}}}^{\\sum_{\\sum_{114514}^{1919810}}^{\\sum_{114514}^{1919810}}} $$\n","date":"2023-03-06T00:00:00Z","permalink":"https://jiansyuan.github.io/post/theorem-proving-and-program-verification-by-coq/","section":"post","tags":["Tutorial","Coq"],"title":"Theorem Proving \u0026 Program Verification by Coq"},{"categories":[],"contents":"Hi! Welcome to my blog website About this website.\n","date":"2023-03-05T00:00:00Z","permalink":"https://jiansyuan.github.io/post/hi-guest/","section":"post","tags":[],"title":"Welcome, guest."},{"categories":null,"contents":"","date":"2019-05-28T00:00:00Z","permalink":"https://jiansyuan.github.io/archives/","section":"","tags":null,"title":""}]